---
title: 05_Docker_能干什么
data: 2019-07-06 23:30:21
tags: 
 - Docker
categories:
 - Docker
 - Docker初学
---

# 05_Docker_能干什么

> 虚拟机（Virtual Machine）就是带环境安装的一种解决方案。

## 传统虚拟化技术与Docker
它可以在一种操作系统里面运行另一种操作系统，比如在windows系统里面运行linux系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美运行了另一套系统，能够使**应用程序，操作系统和硬件三者之间的逻辑不变**。

![虚拟机框架图](https://raw.githubusercontent.com/tomxwd/ImageHosting/master/blog/Docker/05%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A1%86%E6%9E%B6%E5%9B%BE.png)

**虚拟机的缺点：**

1. 资源占用多
2. 冗余步骤多
3. 启动慢

---

由于之前虚拟机存在这些缺点，Linux发展出另一种虚拟化技术：**Linux容器**（Linux Containers，缩写LXC）。

**Linux容器不是虚拟一个完整的操作系统**，而是对进程进行隔离，有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。

![Linux容器](https://raw.githubusercontent.com/tomxwd/ImageHosting/master/blog/Docker/05Linux%E5%AE%B9%E5%99%A8.png)

**Docker与传统虚拟化方式的不同之处：**

- 传统虚拟机技术是虚拟出一套硬件之后，在其上运行一个完整的操作系统，在该操作系统上再运行所需应用进程。
- 而容器内的应用进程直接运行于宿主机的内核，容器内没有自己内核，而且也没有进行硬件虚拟，因此容器要比传统虚拟机更为轻便。
- 每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会互相影响，能区分计算资源。



---
## 开发/运维（DevOps）

> 一次构建、到处运行



#### 更快速的应用交付和部署

传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需要根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。



#### 更便捷的升级和扩缩容器

随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。



#### 更简单的系统运维

应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。



#### 更高效的计算资源利用

Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。



---

## 哪里下载？

1. Docker官网[地址](https://www.docker.com/)
2. Docker Hub仓库[地址](https://hub.docker.com/)

