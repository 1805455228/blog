---
title: 08_Netty_Netty高性能架构设计
date: 2019-12-02 21:17:57
tags: 
 - Netty
categories:
 - Netty
---

# 08_Netty_Netty高性能架构设计

## 线程模型基本介绍

1. 不同的线程模式，对程序的性能有很大影响，为了搞清Netty线程模式，系统看看各个线程模式，最后看看Netty线程模型有何优越性；
2. 目前存在的线程模型有：
   - 传统阻塞I/O服务模型
   - Reactor模式
3. 根据Reactor的数量和处理资源线程池的数量不同，有3种典型的实现
   - 单Reactor单线程
   - 单Reactor多线程
   - 主从Reactor多线程
4. Netty线程模式**（Netty主要基于主从Reactor多线程模型做了一些改进，其中主从Reactor多线程模型有多个Reactor）**；



### 传统阻塞I/O服务模型

![传统阻塞I/O服务模型工作原理图](08_Netty_Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20191202212251818.png)

黄色的框表示对象，蓝色的框代表线程，白色的框标识方法（API）；

模型特点：

1. 采用阻塞I/O模型获取输入的数据
2. 每个连接都需要独立的线程完成数据的输入、业务处理、数据返回

问题分析：

1. 并发数量大的时候，需要创建大量的线程，占用很大的系统资源；
2. 连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞到read操作上，造成线程资源浪费；



### Reactor模式

Reactor对应的叫法：

1. **反应器模式**
2. **分发者模式**（Dispatcher）
3. **通知者模式**（Notifier）

针对传统阻塞I/O服务模型的2个缺点，解决方案：

1. **基于I/O复用模型**：多个连接公用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理的时候，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理；
2. **基于线程池复用线程资源：**不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务；

![image-20191202213608323](08_Netty_Netty%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20191202213608323.png)

整体设计理念（可能有不同的实现，有些许区别，但大体一致）：

1. Reactor模式，通过一个或多个输入同时传递给服务器的模式（基于事件驱动）
2. 服务器端的程序处理传入的多个请求并将它们同步分派到相应的处理线程中去，因此Reactor模式也叫Dispatch模式（分发者模式）
3. Reactor模式使用了IO复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务高并发处理的关键；



#### Reactor模式核心组成

1. **Reactor**：Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。它就像公司的电话接线员，接听来自客户的电话并将线路转移到适当的联系人；
2. **Handlers**：处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作；



#### Reactor模式分类

根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现：

1. 单Reactor单线程
2. 单Reactor多线程
3. 主从Reactor多线程



##### 单Reactor单线程





